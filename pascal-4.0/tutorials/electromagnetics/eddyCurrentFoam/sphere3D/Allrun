#!/bin/bash

flagClean=0; flagPrepare=0; flagParallel=0; flagParallel2=0; flagReset=0; flagRun=0

flagRenumberMesh=0

while [[ $# -gt 0 ]]; do
    if   [[ $1 == 'clean' ]];   then flagClean=1
    elif [[ $1 == 'prepare' ]]; then flagPrepare=1
    elif [[ $1 == 'parallel' ]]; then flagParallel=1
    elif [[ $1 == 'reset' ]];   then flagReset=1
    elif [[ $1 == 'start' ]];   then
        flagPrepare=1
        flagRun=1
    else
      echo "Unsupported flag: '$1'"
    fi
    shift
done

# Helper functions
. $WM_PROJECT_USER_DIR/etc/helpFunctions.sh
. $WM_PROJECT_USER_DIR/etc/cleanFunctions.sh

setErrorTrap

regionlist="region_conductor"

if [[ $flagClean -eq 1 ]]; then

    # Cleanup
    cleanCase
    for region in $regionlist; do
        cleanCase "$region"
    done

    # Wipe folders with org backup
    wipeOrgCopy
    for region in $regionlist; do
        wipeOrgCopy "$region"
    done

    # Wipe polymesh for regions
    wipePolyMesh
    for region in $regionlist; do
        wipePolyMesh "$region"
    done

    # Clean tools
    cleanTools

fi

if [[ $flagPrepare -eq 1 && $flagClean -eq 1 ]]; then

    # Restore polymesh folder from org backup
    restorePolyMeshOrg

    # Create polyMesh with blockMesh
    ./constant/polyMesh/blockMeshDict.py
    runApplication \
        blockMesh || exit 1

    # Mirror mesh in all directions
    directions="x y z"
    for d in $directions; do

        cp "system/mirrorMeshDict.$d" 'system/mirrorMeshDict'

        runApplication -l "log.mirrorMesh.$d" \
            mirrorMesh || exit 1

    done

    # Move polyMesh into constant
    moveZeroToConstantPolyMesh

    # Remove all zones
    rm 'constant/polyMesh/cellZones' > /dev/null 2>&1
    rm 'constant/polyMesh/faceZones' > /dev/null 2>&1
    rm 'constant/polyMesh/pointZones' > /dev/null 2>&1

    # Create new topoSets
    runApplication \
        setSet -noVTK -batch 'system/setSetBatch' || exit 1

    # Create new patches
    runApplication \
        createPatch -overwrite || exit 1

    # Change dictionaries
    runApplication \
        changeDictionary || exit 1

    # Create subset meshes
    # for regions
    for region in $regionlist; do

        runApplication -r "$region" \
            subsetMesh "cellSet_$region" -overwrite || exit 1

        mkdir 'constant/setSubset' > /dev/null 2>&1
        mkdir 'constant/setSubset/polyMesh' > /dev/null 2>&1
        mv "0/setSubset/polyMesh/"* "constant/setSubset/polyMesh/"
        mkdir "constant/$region" > /dev/null 2>&1
        mkdir "constant/$region/polyMesh" > /dev/null 2>&1
        mv "constant/setSubset/polyMesh/"* "constant/$region/polyMesh"
        rm -rf "0/setSubset"
        rm -rf "constant/setSubset"
        rm -rf "system/setSubset"

        runApplication -r "$region" \
            createPatch -region "$region" -overwrite || exit 1

    done

    # Add fields to 0 from org backup
    addZeroOrg

    # Move polyMesh from 0 to constant
    # for regions
    for region in $regionlist; do
        moveZeroToConstantPolyMesh "$region"
    done

    # Add fields to 0 from org backup
    # for regions
    for region in $regionlist; do
        addZeroOrg "$region"
    done

    runApplication \
        funkySetFields -time '0' || exit 1

    # Touch paraFoam files
    paraviewTouchOpenFOAM

    if [[ $flagParallel -eq 1 ]]; then

        # Decompose mesh
        runApplication \
            decomposePar || exit 1

        # Decompose mesh
        # for regions
        for region in $regionlist; do
            runApplication -r "$region" \
                decomposePar -region $region || exit 1
        done

        # Decompose sets
        # for regions
        for region in $regionlist; do
            runApplication -r "$region" \
                decomposeSets -region $region || exit 1
        done

        # Decompose region addressings
        # for regions
        for region in $regionlist; do
            runApplication -r "$region" \
                decomposeRegionAddressing -region $region || exit 1
        done

        # Touch paraFoam files
        paraviewTouchOpenFOAMParallel
    fi
fi

if [[ $flagReset -eq 1 ]]; then

    if [[ $flagParallel -eq 1 ]] || \
       [[ $flagParallel2 -eq 1 ]]; then

        # Clean time directories
        cleanTimeDirectoriesParallel

    else

        # Clean time directories
        cleanTimeDirectories

    fi

    # Remove solver log
    rm "log.$(getApplication)" > /dev/null 2>&1

fi

if [[ $flagRun -eq 1 ]]; then
    if [[ $flagParallel -eq 1 ]] || \
       [[ $flagParallel2 -eq 1 ]]; then

        np=$(ls -1d processor* | wc -l)
        runParallel $np \
            $(getApplication) || exit 1

    else

        runApplication \
            $(getApplication) || exit 1

    fi
fi
